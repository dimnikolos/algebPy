\chapter{Δεκαδικοί αριθμοί}
\section{Εισαγωγή}
Αν χωρίσουμε τη μονάδα σε 10 ίσα μέρη τότε μπορούμε να πάρουμε κλάσματα της μονάδας όπως $\frac{3}{10}$, $\frac{5}{10}$ κλπ. Τα κλάσματα είναι ομώνυμα συγκρίνονται εύκολα και βοηθάνε στις πράξεις. 
Γενικότερα, ονομάζουμε δεκαδικό κλάσμα οποιδήποτε κλάσμα έχει παρονομαστή μια δύναμη του 10. Κάθε δεκαδικό κλάσμα γράφεται σαν δεκαδικός αριθμός με τόσα δεκαδικά ψηφία όσα μηδενικά έχει ο παρονομαστής του.
Η Python χειρίζεται τους δεκαδικούς αριθμούς όπως και τους υπόλοιπους.
Δοκίμασε:
\begin{lstlisting}
>>> 0.3 + 0.5
0.8
>>> type(0.7)
<class 'float'>
\end{lstlisting}

Βλέπουμε ότι οι δεκαδικοί αριθμοί δεν είναι int, όπως οι ακέραιο αλλά float. Το όνομα float έχει να κάνει με τον τρόπο με τον οποίο ο υπολογιστής αποθηκεύει αποδοτικά αυτούς τους αριθμούς. 

Ας συνδυάσουμε τις γνώσεις από τα κλάσματα με τα κλάσματα που μάθαμε στο προηγούμενο κεφάλαιο.
\begin{lstlisting}
>>> from fractions import Fraction
>>> x = Fraction(3,10)
>>> float(x)
0.3
\end{lstlisting}

Το \lstinline{Fraction(3,10)} εννοεί το κλάσμα $\frac{3}{10}$ που είναι ίσο με 0,3. Όμως στην Python το 0,3 θα το γράφουμε με 0.3. Με τη συνάρτηση float μετατρέπουμε το $\frac{3}{10}$ σε δεκαδικό αριθμό.

\begin{exercise}
\sel{56} Γράψτε τους αριθμούς $\frac{3}{10}$, $\frac{825}{1000}$, $\frac{53}{1000}$, $\frac{1004}{10000}$.
\end{exercise}
\begin{lstlisting}
>>> float(Fraction(3,10))
0.625
>>> float(Fraction(825,100))
8.25
>>> float(Fraction(53,1000))
0.053
>>> float(Fraction(1004,10000))
0.1004
\end{lstlisting}

Η Python μπορεί να μετατρέψει τα κλάσματα σε δεκαδικό αριθμό ανεξάρτητα από τον παρονομαστή.
\begin{exercise}
\sel{59} Γράψε καθένα από τα παρακάτω κλάσματα, ως δεκαδικό αριθμό: (i) με προσέγγιση
εκατοστού και (ii) με προσέγγιση χιλιοστού: 

(α) $\frac{7}{16}$

(β) $\frac{21}{17}$

(γ) $\frac{20}{95}$
\end{exercise}
\begin{lstlisting}
>>> x = Fraction(7,16)
>>> float(x)
0.4375
>>> round(float(x),2)
0.44
>>> round(float(x),3)
0.438
>>> x = Fraction(21,17)
>>> float(x)
1.2352941176470589
>>> round(float(x),2)
1.24
>>> round(float(x),3)
1.235
>>> x = Fraction(20,95)
>>> float(x)
0.21052631578947367
>>> round(float(x),2)
0.21
>>> round(float(x),3)
0.211
\end{lstlisting}


Η στρογγυλοποίηση των δεκαδικών υλοποιείται στην Python με τη συνάρτηση round. Οπότε μπορείς να στρογγυλοποιήσεις εύκολα δεκαδικούς αριθμούς ως εξής:
\begin{exercise}
Να στρογγυλοποιήσεις τους παρακάτω δεκαδικούς αριθμούς στο δέκατο, εκατοστό και
χιλιοστό: 

(α) 9876,008, 

(β) 67,8956, 

(γ) 0,001, 

(δ) 8,239, 

(ε) 23,7048.
\end{exercise}
Θυμόμαστε να αλλάζουμε την υποδιαστολή από κόμμα σε τελεία:
\begin{lstlisting}
def roundall(x):
    print(round(x,1))
    print(round(x,2))
    print(round(x,3))

roundall(9876.008)
roundall(67.8956)
roundall(0.001)
roundall(8.239)
roundall(23.7048)
\end{lstlisting}

To αποτέλεσμα είναι:
\begin{lstlisting}
67.9
67.9
67.896
0.0
0.0
0.001
8.2
8.24
8.239
23.7
23.7
23.705
\end{lstlisting}

\begin{exercise}
\sel{59} Στον αριθμό $34,\square\square\square$ λείπουν τα τελευταία τρία ψηφία του. Να συμπληρώσεις τον
αριθμό με τα ψηφία 9, 5 και 2, έτσι ώστε κάθε ψηφίο να γράφεται μία μόνο φορά. Να γράψεις όλους τους δεκαδικούς που μπορείς να βρεις και να τους διατάξεις σε φθίνουσα σειρά.
\end{exercise}

Πώς μπορεί η Python να βρει όλους τους πιθανούς συνδυασμούς του 9,5,2;
Δοκίμασε τη βιβλιοθήκη itertools και συγκεκριμένα τη συνάρτηση permutations.
\begin{lstlisting}
>>> from itertools import permutations
>>> x = permutations([1,2,3])
>>> print(x)
<itertools.permutations object at 0x012BE1B0>
>>> print(list(x))
[(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]
\end{lstlisting}
Έτσι με την permutations μπορείς να βρεις όλες τις αναδιατάξεις των αριθμών. Οπότε τώρα το πρόγραμμα μπορεί να γίνει ως εξής:
\begin{lstlisting}
lista = []
from itertools import permutations
for p in permutations([9,5,2]):
    lista.append(34+p[0]/10+p[1]/100+p[2]/1000)
print(lista)
\end{lstlisting}
Που δίνει το αποτέλεσμα:
\begin{lstlisting}
[34.952, 34.925000000000004, 34.592000000000006, 34.529, 
34.29500000000001, 34.259]
\end{lstlisting}
Τα ψηφία που εμφανίζονται στο τέλος των αριθμών προκύπτουν από την αναπαράσταση των δεκαδικών στον υπολογιστή που υπόκειται σε κάποιους περιορισμούς.
Αν δεν θέλουμε να εμφανίζονται μπορούμε να αλλάξουμε το for σε:
\begin{lstlisting}
for p in permutations([9,5,2]):
    ar = 34+p[0]/10+p[1]/100+p[2]/1000
    lista.append(round(ar,3))
\end{lstlisting}
Τώρα για να γράψουμε τους αριθμούς με φθίνουσα σειρά θα δοκιμάσουμε τη sorted. Η sorted ταξινομεί τους αριθμούς που δίνονται σε μια λίστα. Δοκίμασε:
\begin{lstlisting}
>>> sorted([4,2,3])
[2, 3, 4]
\end{lstlisting}
Έτσι το συνολικό πρόγραμμα γίνεται:
\begin{lstlisting}
lista = []
from itertools import permutations
for p in permutations([9,5,2]):
    ar = 34+p[0]/10+p[1]/100+p[2]/1000
    lista.append(round(ar,3))
print(sorted(lista))
\end{lstlisting}

Που δίνει το αποτέλεσμα:
\begin{lstlisting}
[34.259, 34.295, 34.529, 34.592, 34.925, 34.952]
\end{lstlisting}

Όμως η άσκηση μας ζητάει να τυπώσουμε τη λίστα με φθίνουσα σειρά. Αυτό μπορεί να γίνει δηλώνοντας στη sorted ότι θέλουμε αντίστροφη σειρά γράφοντας \lstinline{reverse=True}. Το τελικό πρόγραμμα είναι το εξής:
\begin{lstlisting}
lista = []
from itertools import permutations
for p in permutations([9,5,2]):
    ar = 34+p[0]/10+p[1]/100+p[2]/1000
    lista.append(round(ar,3))
print(sorted(lista,reverse=True))
\end{lstlisting}

Μια μικρή τροποποίηση που μπορεί να γίνει για να εμφανιστούν οι αριθμοί σε διαφορετικές γραμμές είναι να τυπώσουμε τη λίστα με μια for.
\begin{lstlisting}
lista = []
from itertools import permutations
for p in permutations([9,5,2]):
    ar = 34+p[0]/10+p[1]/100+p[2]/1000
    lista.append(round(ar,3))

for x in sorted(lista,reverse=True):
    print(x)
\end{lstlisting}

\begin{exercise}
\sel{61} Να υπολογίσεις τα αθροίσματα:

(α) $48,18 + 3,256 + 7,129$

(β) $3,59 + 7,13 + 8,195$
\end{exercise}

\begin{lstlisting}
>>> 48.18+3.256+7.129
58.565
>>> 3.59 + 7.13 + 8.195
18.915
\end{lstlisting}
\begin{exercise}
\sel{61}
Να υπολογίσεις το μήκος της περιμέτρου των οικοπέδων:
(Σχήμα ---)
\end{exercise}
\begin{lstlisting}
>>> 26.14 + 80.19 + 29.13+38.13+23.24+57.89+80.19
334.91
>>> 39.93+80.19+57.89+47.73+44.75+48.9+47.19
366.58
\end{lstlisting}
\begin{exercise}
\sel{61} Να κάνεις τις διαρέσεις:
(α) $579:48$

(β) $314:25$

(γ) $520:5,14$

(δ) $49,35:7$

\end{exercise}
\begin{lstlisting}
>>> 579/48
12.0625
>>> 314/25
12.56
>>> 520/5.14
101.16731517509729
>>> 49.35/7
7.05
\end{lstlisting}
\begin{exercise}
\sel{61}
Να κάνεις τις πράξεις: 

(α) $520 \cdot 0,1 + 0,32 \cdot 100 $

(β) $4,91 \cdot 0,01 + 0,819 \cdot 10$

\end{exercise}

\begin{lstlisting}
>>> 520*0.1 + 0.32*100
84.0
>>> 4.91*0.01 + 0.819*10
8.239099999999999
\end
\end{lstlisting}

Σε αυτή την άσκηση βλέπουμε ότι ο υπολογιστής προσεγγίζει τα αποτελέσματα με τον δικό του τρόπο.
Δοκίμασε:
\begin{lstlisting}
>>> x = 520*0.1 + 0.32*100
>>> x
84.0
>>> type(x)
<class 'float'>
>>> y = int(x)
>>> type(y)
<class 'int'>
>>> x == y
True
\end{lstlisting}
Αυτό σημαίνει πως ο ακέραιος αριθμός 84, και κάθε ακέραιος, στην Python μπορεί να αναπαρασταθεί σαν ακέραιος αλλά και σαν float με μηδενικά δεκαδικά ψηφία.
Στην δεύτερη πράξη παρατηρούμε ότι αντί για το σωστό αποτέλεσμα που είναι $0,0491+8,19=8,2391$ η Python εμφανίζει μια προσέγγιση που είναι $8.239099999999999$. Η διαφορά είναι πολύ μικρή. Ωστόσο οι δύο ποσότητες δεν είναι ίσες.
Δοκίμασε:
\begin{lstlisting}
>>> 4.91*0.01 + 0.819*10 == 8.2391
False
>>> 8.2391 - 4.91*0.01 + 0.819*10 
1.7763568394002505e-15
\end{lstlisting}
Ο αριθμός \lstinline{1.7763568394002505e-15} σημαίνει πως η διαφορά είναι περίπου $1.77\cot 10^{-15}$ που είναι πάρα πολύ μικρή και προκύπτει από τον τρόπο με τον οποίο η Python αποθηκεύει τους αριθμούς.

\begin{exercise}
\sel{61}
Να κάνεις τις πράξεις:

(α) $4,7:0,1-45:10$

(β) $0,98:0,0001 - 6785:1000$
\end{exercise}

\begin{lstlisting}
>>> 4.7/0.1 - 45/10
42.5
>>> 0.98/0.0001 - 6785/1000
9793.215
\end{lstlisting}
Βλέπουμε ότι η Python υπολογίζει σωστά πρώτα τη διαίρεση και μετά την αφαίρεση.

\begin{exercise}
\sel{61}
Η περίμετρος ενός τετραγώνου είναι 20,2. Να υπολογίσεις την πλευρά του.
\end{exercise}
\begin{lstlisting}
>>> 20.2/4
5.05
\end{lstlisting}

\begin{exercise}
\sel{61}
Η περίμετρος ενός ισοσκελούς τριγώνου είναι 48,52. Αν η βάση του είναι 10,7, πόσο είναι η κάθε μία από τις ίσες πλευρές του;
\end{exercise}
Αφαιρούμε πρώτα από το 48,52 το 10,7. Το αποτελέσμα το διαιρούμε με το δυο.
\begin{lstlisting}
>>> 48.52-10.7
37.82000000000001
>>> 37.82/2
18.91
\end{lstlisting}

\begin{exercise}
\sel{61}
Να υπολογίσεις τις τιμές των αριθμητικών παραστάσεων:

(α) $24\cdot 5 - 2 + 3 \cdot 5$

(β) $3\cdot 11 -2 + 45,1 : 2$
\end{exercise}
\begin{lstlisting}
>>> 24*5 - 2 +3*5
133
>>> 3*11 - 2 + 54.1/2
58.05
\end{lstlisting}

\begin{exercise}
\sel{61}
Να υπολογίσεις τις δυνάμεις:
(α) $3,1^2$, (β) $7,01^2$, (γ) $4,5^2$, (δ) $0,5^2$, (ε) $0,2^2$, (στ) $0,3^3$
\end{exercise}
\begin{lstlisting}
>>> 3.1**2
9.610000000000001
>>> 7.01**2
49.1401
>>> 4.5**2
20.25
>>> 0.5**2
0.25
>>> 0.2**2
0.04000000000000001
>>> 0.3*3
0.8999999999999999
\end{lstlisting}
Πάλι κάνουν την εμφάνισή τους μικρές προσεγγίσεις.

\begin{exercise}
Τοποθέτησε ένα ``x'' στην αντίστοιχη θέση (ΣΩΣΤΟ ΛΑΘΟΣ)
(α) $2,75 + 0,05 + 1,40 + 16,80 = 21$
(β) $420,510 + 72,490 + 45,19 + 11,81 = 500$
(γ) $4 – 3,852 = 1,148$
(δ) $32,01 – 4,001 = 28,01$
(ε) $41900 \cdot 0,0001 – 0,0419 \cdot 1000 = 0$
(στ) $56,89 \cdot 0,01 + 4311 : 10000 = 1$
(ζ) $(3,2 + 7,2 \cdot 2 + 24 \cdot 0,1) : 100 = 0,2$
\end{exercise}

(α)
\begin{lstlisting}
>>> 2.75 + 0.05 + 1.40 + 16.80 == 21
True
>>> 2.75 + 0.05 + 1.40 + 16.80
21.0
\end{lstlisting}
Άρα Σωστό

(β)
\begin{lstlisting}
>>> 420.510 + 72.490 + 45.19 + 11.81 == 500
False
>>> 420.510 + 72.490 + 45.19 + 11.81
550.0
\end{lstlisting}
Άρα Λάθος

(γ)
\begin{lstlisting}
>>> 4 - 3.852 == 1.148
False
>>> 4 - 3.852
0.14800000000000013
\end{lstlisting}
Άρα Λάθος

(δ)
\begin{lstlisting}
>>> 32.01 - 4.001 == 28.01
False
>>> 32.01 - 4.001
28.008999999999997
\end{lstlisting}
Άρα Λάθος

(ε)
\begin{lstlisting}
>>> 41900*0.0001 - 0.0419*1000 == 0
False
>>> 41900*0.0001 - 0.0419*1000
-37.71
\end{lstlisting}
Άρα Λάθος

(στ)
\begin{lstlisting}
>>> 56.89*0.01 + 4311 / 10000 == 1
True
>>> 56.89*0.01 + 4311 / 10000
1.0
\end{lstlisting}
Άρα Σωστό

και 

(ζ)
\begin{lstlisting}
>>> (3.2 + 7.2*2 + 24*0.1) / 100 == 0.2
True
>>> (3.2 + 7.2*2 + 24*0.1) / 100
0.2
\end{lstlisting}

Άρα Σωστό.


\section{Τυποποιημένη μορφή μεγάλων αριθμών}
Η μάζα του Ήλιου είναι 1983000000000000000000000000000 κιλά. Για να διευκολυνθούμε μπορούμε να γράψουμε αυτόν τον αριθμό στην μορφή $\alpha \cdot 10^ν$. Αρχικά μετράμε τα μηδενικά:
$$1983.000.000.000.000.000.000.000.000.000$$
ο αριθμός μας γίνεται:
$$1983\cdot 10^{27}$$
Η τυποποιημένη μορφή απαιτεί το $\alpha$ να είναι μεγαλύτερο ή ίσο του 1 και μικρότερο του 10. Οπότε το 1983 πρέπει να γίνει 1,983 και ο αριθμός μας να γίνει 
$$1,983\cdot 10^{30}$$
σε τυποποιημένη μορφή μεγάλων αριθμών.
Η Python υποστηρίζει την τυποποιημένη μορφή μεγάλων αριθμών με τη χρήση της εντολής format.
Δοκίμασε:
\begin{lstlisting}
>>> x = 1983000000000000000000000000000
>>> print(x)
1983000000000000000000000000000
>>> print('{:.3e}'.format(x))
1.983e+30
\end{lstlisting}
H γενική μορφή είναι να χρησιμοποιείς \lstinline|<'{:.Ne}'.format(x)>|όπου Ν είναι το πλήθος των δεκαδικών ψηφίων που θες να εμφανίζονται. Έτσι
\begin{lstlisting}
>>> print('{:.2e}'.format(3140000000000000000))
3.14e+18
>>> print('{:.2e}'.format(234000000000000000))
2.34e+17
\end{lstlisting}
Η Python καταλαβαίνει την τυποποιημένη μορφή π.χ.:
\begin{lstlisting}
>>> x = 3.14e+30
>>> print(x)
3.14e+30
>>> print('{:.0f}'.format(x))
3139999999999999741556248543232
\end{lstlisting}
To '{:.0f}' σημαίνει πως ο αριθμός θα πρέπει να γραφεί σαν δεκαδικός (float) με μηδεν δεκαδικά ψηφία
\begin{exercise}
\sel{63}
Να γράψεις τους παρακάτω αριθμούς στην τυποποιημένη μορφή:
(α) 583.000 (β) 4.300.000 (γ) 7.960.000 (δ) 3.420.000.000 (ε) 4.800 (στ) 7.310
(ζ) 281.900 (η) 518.000.000 (θ) 131.000 (ι) 675.000.
\end{exercise}
\begin{lstlisting}
>>> print('{:.2e}'.format(583000))
5.83e+05
>>> print('{:.1e}'.format(4300000))
4.3e+06
>>> print('{:.2e}'.format(7960000))
7.96e+06
>>> print('{:.2e}'.format(3420000000))
3.42e+09
>>> print('{:.1e}'.format(4800))
4.8e+03
>>> print('{:.2e}'.format(7310))
7.31e+03
>>> print('{:.3e}'.format(281900))
2.819e+05
>>> print('{:.2e}'.format(518000000))
5.18e+08
>>> print('{:.2e}'.format(131000))
1.31e+05
>>> print('{:.2e}'.format(675000))
6.75e+05
\end{lstlisting}
\begin{exercise}
\sel{63}
Nα γράψεις τη δεκαδική μορφή των αριθμών:
(α) $3,1 \cdot 106$ (β) $4,820 \cdot 105$ (γ) $3,25 \cdot 104$ (δ) $7,4 \cdot 103$ (ε) $9,2 \cdot 102$.
\end{exercise}
\begin{lstlisting}
>>> print(4.820 * 10**5)
482000.0
>>> print(3.25 * 10**4)
32500.0
>>> print(7.4 * 10**3)
7400.0
>>> print(9.2 * 10**2)
919.9999999999999
\end{lstlisting}
Ειδικά για το τελευταίο παρατηρούμε ότι έχουμε μια προσέγγιση και αντί για 920 που είναι το σωστό αποτέλεσμα προκύπτει 919.9999999999999. H Python κάνει προσεγγίσεις όταν χρειάζεται να κάνει πράξεις ή όταν ο αριθμός δεν μπορεί να αναπαρασταθεί στα όρια του υπολογιστή. Το 920 δεν ανήκει στην δεύτερη κατηγορία οπότε το λάθος προκύπτει από την πράξη (πολλαπλασιαμός με το 100). Στην πραγματικότητα ο πολλαπλασιασμός αυτός δεν είναι αναγκαίος μπορείς να γράψεις 9.2e2 αντί για 9.2*10**2 και η Python θα καταλάβει τον αριθμό που θέλεις:
\begin{lstlisting}
>>> 9.2e2
920.0
\end{lstlisting}
\begin{exercise}
Nα εκφραστεί το μήκος των 2.754,389 m, σε όλες τις υποδιαιρέσεις του m.
\end{exercise}
Οι υποδιαιρέσεις του μέτρου (m) είναι τα δεκατόμετρα (dm), τα εκατοστόμετρα (cm) και τα χιλιοστόμετρα (mm).
Για να εκφραστεί το μήκος σε κάθε μία από τις υποδιαιρέσεις θα πρέπει να το πολλαπλασιάζουμε με το 10. 
Δοκίμασε:
\begin{lstlisting}
>>> x = 2754.389
>>> x = 10*x
>>> print(x)
27543.89
>>> x = 10*x
>>> print(x)
275438.9
>>> x = 10*x
>>> print(x)
2754389.0
\end{lstlisting}
Οπότε έχουμε 27543.89 δεκατόμετρα, 275438.9 εκατοστόμετρα και 2754389 χιλιοστόμετρα.
Μπορούμε να μετατρέψουμε τα παραπάνω σε πρόγραμμα ως εξής:
\begin{lstlisting}
x = float(input('Μήκος σε μέτρα:'))
for i in range(3):
    x = 10*x
    print(x)
\end{lstlisting}
Που δίνει το εξής αποτέλεσμα:
\begin{lstlisting}
Μήκος σε μέτρα:2754.389
27543.89
275438.9
2754389.0
\end{lstlisting}
Ακόμη καλύτερα θα ήταν να κάνουμε:
\begin{lstlisting}
x = float(input('Μήκος σε μέτρα:'))
monades = ['dm','cm','mm']
for i in range(3):
    x = 10*x
    print(x,monades[i])
\end{lstlisting}
Αν ξέχασες το float πριν το input θα δεις ότι ο πολλαπλασιασμός μεταξύ ακεραίου και αλφαρηθμιτικού δουλεύει, και αντιγράφει το ίδιο αλφαριθμητικό πολλές φορές, δοκίμασε:
\begin{lstlisting}
>>> x = input('Μήκος σε μέτρα:')
Μήκος σε μέτρα:2754.389
>>> 10*x
'2754.3892754.3892754.3892754.3892754.3892754.3892754.3892754.3892754.3892754.389'
\end{lstlisting}
\begin{exercise} 
Η επιφάνεια ενός κύβου έχει εμβαδόν 96 cm$^2$. Να βρεθεί ο όγκος του.
\end{exercise}
Η λύση του βιβλίου είναι:

Επειδή ο κύβος έχει 6 έδρες, η κάθε έδρα του θα έχει εμβαδόν $96\textrm{cm}^2 : 6 = 16\textrm{cm}^2$.

Αλλά είναι $16\textrm{cm}^2 = 4\textrm{cm} \cdot 4\textrm{cm} = (4\textrm{cm})^2$, άρα, η ακμή του κύβου είναι 4cm.

Επομένως, ο όγκος του κύβου είναι: $(4\textrm{cm})^3 = 4\textrm{cm} \cdot 4\textrm{cm} \cdot 4\textrm{cm} = 64 \textrm{cm}^3$

Σε Python η λύση προχωράει ως εξής:
\begin{lstlisting}
>>> epifaneia = 96
>>> epifaneiaPlevras = epifaneia/6
16
\end{lstlisting}

Εμείς ξέρουμε ότι $4^2=16$ και μπορούμε να το θυμηθούμε. Ο υπολογιστής όμως δεν το ξέρει και πρέπει να έχει μια συνάρτηση για να υπολογίσει τον αριθμό που αν τον υψώσουμε στο τετράγωνο θα κάνει 16. Ευτυχώς, αυτή η συνάρτηση υπάρχει λέγεται sqrt και βρίσκεται στη βιβλιοθήκη math. Οπότε μπορούμε να τη χρησιμοποιήσουμε ως εξής:
\begin{lstlisting}
>>> import math
>>> math.sqrt(16)
4.0
\end{lstlisting}
και από εκεί μπορούμε να υπολογίσουμε τον όγκο υψώνοντας στην τρίτη.

Συνολικά το πρόγραμμά μας γίνεται:
\begin{lstlisting}
import math
epifaneia = 96
epifaneiaPlevras = epifaneia/6
akmi = math.sqrt(epifaneiaPlevras)
ogkos = akmi**3
print(ogkos)
\end{lstlisting}
που δίνει το αποτέλεσμα:
\begin{lstlisting}
64.0
\end{lstlisting}

Το ίδιο πρόγραμμα μπορούμε να το χρησιμοποιήσουμε και για να βρούμε τον όγκο ενός κύβου με επιφάνεια 54. Αφού έχουμε
$54:6=9$ άρα η ακμή του κύβου είναι $3$ και ο όγκος του $27$. Το παρακάτω πρόγραμμα δίνει το σωστό αποτέλεσμα:
\begin{lstlisting}
import math
epifaneia = 54
epifaneiaPlevras = epifaneia/6
akmi = math.sqrt(epifaneiaPlevras)
ogkos = akmi**3
print(ogkos)
\end{lstlisting}

Μπορούμε να γράψουμε ένα πρόγραμμα που να του δίνουμε την επιφάνεια ενός κύβου και να μας βρίσκει τον όγκο του το πρόγραμμα αυτό είναι το εξής:
\begin{lstlisting}
import math
epifaneia = int(input('Δώσε επιφάνεια κύβου: '))
epifaneiaPlevras = epifaneia/6
akmi = math.sqrt(epifaneiaPlevras)
ogkos = akmi**3
print('Ο όγκος του κύβου είναι: ', ogkos)
\end{lstlisting}

Τέλος, μπορούμε να γράψουμε μια συνάρτηση που να υπολογίζει τον όγκο ενός κύβου από την επιφάνειά του:
\begin{lstlisting}
import math
def ogkosapoepifaneia(epifaneia):
    epifaneiaPlevras = epifaneia/6
    akmi = math.sqrt(epifaneiaPlevras)
    ogkos = akmi**3
    return(ogkos)
epifaneia = int(input('Δώσε επιφάνεια κύβου: '))
print('Ο όγκος του κύβου είναι: ', ogkosapoepifaneia(epifaneia))
\end{lstlisting}
    
 

\begin{exercise}
\sel{66}Mια αμαξοστοιχία διανύει την απόσταση Αθήνας -
Πύργου σε 4 ώρες και 57 λεπτά.
Αν η αμαξοστοιχία ξεκινά από την Αθήνα στις 9:10
π.μ. το πρωί, ποια ώρα θα φτάσει στον Πύργο;
\end{exercise}
Πώς μπορούμε στην Python να κάνουμε πράξεις με τις ώρες;  Υπάρχουν δύο τρόποι:
α)
Να τα υπολογίσουμε με όσα γνωρίζουμε:
Έτσι αν έχουμε θέλουμε να προσθέσουμε 9h και 10m με 4h και 57m οπότε ξεκινάμε από τα λεπτά και βρίσκουμε τις ώρες μετά. Ένας τρόπος είναι λοιπόν ο εξής:
\begin{lstlisting}
anaxWra = 9
anaxLepta = 10
diarkeiaWra = 4
diarkeiaLepta = 57
athroismaLepta = anaxLepta + diarkeiaLepta
telikaLepta = athroismaLepta % 60
telikiWra = anaxWra + diarkeiaWra + athroismaLepta // 60
if telikiWra > 12:
    print(str(telikiWra ) + ':' + str(telikaLepta - 12)+ ' μ.μ.')
else:
    print(str(telikiWra)+':'+str(telikaLepta) + 'π.μ.')
\end{lstlisting}

Όπως καταλαβαίνεις το θέμα δεν είναι να υπολογίσεις μια φορά το αποτέλεσμα αλλά να φτιάξεις ένα πρόγραμμα που να υπολογίζει το αποτέλεσμα αν ο χρήστης δίνει την ώρα αναχώρησης και τη διάρκεια του ταξιδιού. Αυτό μπορεί να γίνει με την input και τη split.
\begin{lstlisting}
anax = input('Αναχώρηση (μορφή ωω:λλ)>')
diarkeia = input('Διάρκεια (μορφή ωω:λλ)>')
anaxWra = int(anax.split(':')[0])
anaxLepta = int(anax.split(':')[1])
diarkeiaWra = int(diarkeia.split(':')[0])
diarkeiaLepta = int(diarkeia.split(':')[1])
athroismaLepta = anaxLepta + diarkeiaLepta
telikaLepta = athroismaLepta % 60
telikiWra = anaxWra + diarkeiaWra + athroismaLepta // 60
if telikiWra > 12:
    print(str(telikiWra ) + ':' + str(telikaLepta -12)+ ' μ.μ.')
else:
    print(str(telikiWra)+':'+str(telikaLepta) + 'π.μ.')
\end{lstlisting}

Το παραπάνω πρόγραμμα μας δίνει τη σωστή απάντηση σε πολλές περιπτώσεις. Όχι όμως σε όλες. Δείτε:
\begin{lstlisting}
Αναχώρηση (μορφή ωω:λλ)>19:30
Διάρκεια (μορφή ωω:λλ)>5:40
25:-2 μ.μ.
\end{lstlisting}
Θα πρέπει λοιπόν να φτιάξουμε το άθροισμα της ώρας να μην ξεπερνάει το 24.
\begin{lstlisting}
anax = input('Αναχώρηση (μορφή ωω:λλ)>')
diarkeia = input('Διάρκεια (μορφή ωω:λλ)>')
anaxWra = int(anax.split(':')[0])
anaxLepta = int(anax.split(':')[1])
diarkeiaWra = int(diarkeia.split(':')[0])
diarkeiaLepta = int(diarkeia.split(':')[1])
athroismaLepta = anaxLepta + diarkeiaLepta
telikaLepta = athroismaLepta % 60
telikiWra = (anaxWra + diarkeiaWra + athroismaLepta // 60) % 24
if telikiWra > 12:
    print(str(telikiWra ) + ':' + str(telikaLepta -12)+ ' μ.μ.')
else:
    print(str(telikiWra)+':'+str(telikaLepta) + 'π.μ.')
\end{lstlisting}

Τότε παίρνουμε το σωστό αποτέλεσμα:
\begin{lstlisting}
Αναχώρηση (μορφή ωω:λλ)>19:30
Διάρκεια (μορφή ωω:λλ)>5:40
1:10π.μ.
\end{lstlisting}

β)
Ο δεύτερος τρόπος είναι να χρησιμοποιήσουμε τη βιβλιοθήκη datetime η οποία χρειάζεται κάποιους ειδικούς χειρισμούς.
\begin{lstlisting}
import datetime

anax = input('Αναχώρηση (μορφή ωω:λλ)>')
diarkeia = input('Διάρκεια (μορφή ωω:λλ)>')
anaxWra = int(anax.split(':')[0])
anaxLepta = int(anax.split(':')[1])
diarkeiaWra = int(diarkeia.split(':')[0])
diarkeiaLepta = int(diarkeia.split(':')[1])
t = datetime.time(9,10)
t = datetime.datetime.combine(datetime.date(2020,5,25),t)
d = datetime.timedelta(hours = 4, minutes=57)
print((t+d).strftime('%H:%M'))
\end{lstlisting}

Μπορούμε να μικρύνουμε λίγο ακόμη το πρόγραμμα ως εξής:
\begin{lstlisting}
import datetime

anax = input('Αναχώρηση (μορφή ωω:λλ)>')
diarkeia = input('Διάρκεια (μορφή ωω:λλ)>')
t = datetime.time(int(anax.split(':')[0]),int(anax.split(':')[1]))
t = datetime.datetime.combine(datetime.date(2020,5,25),t)
d = datetime.timedelta(hours = int(diarkeia.split(':')[0]), 
    minutes=int(diarkeia.split(':')[1]))
print((t+d).strftime('%H:%M'))
\end{lstlisting}

Το αποτέλεσμα του προγράμματος με τα δεδομένα του προβλήματος είναι:
\begin{lstlisting}
Αναχώρηση (μορφή ωω:λλ)>9:10
Διάρκεια (μορφή ωω:λλ)>4:57
14:07
\end{lstlisting}

Αν δώσουμε διαφορετικά δεδομένα παίρνουμε σωστές απαντήσεις:
\begin{lstlisting}
Αναχώρηση (μορφή ωω:λλ)>14:10
Διάρκεια (μορφή ωω:λλ)>5:30
19:40
\end{lstlisting}

και για τις ειδικές περιπτώσεις:
\begin{lstlisting}
Αναχώρηση (μορφή ωω:λλ)>19:30
Διάρκεια (μορφή ωω:λλ)>5:40
01:10
\end{lstlisting}

\begin{exercise}
\sel{67}
Να βρεθεί η περίμετρος του σχήματος: (α) σε μέτρα, (β) σε εκατοστά και
(γ) σε χιλιόμετρα.
\end{exercise}
Λύση
(α) Η περίμετρος σε μέτρα είναι ίση με το άθροισμα
των μηκών των πλευρών του, δηλαδή:
\begin{lstlisting}
>>> 26.6+23.5+22.17+38.53
111.8
\end{lstlisting}
Για να το μετατρέψουμε σε εκατοστά θα πολλαπλασιάσουμε με το 100
\begin{lstlisting}
>>> 111.8*100
11180
\end{lstlisting}
Για να το μετατρέψουμε σε χιλιόμετρα θα διαιρέσουμε με το 1000:
\begin{lstlisting}
>>> 111.8/1000
0,1118
\end{lstlisting}

\begin{exercise}
\sel{67}
Μια δεξαμενή νερού τρύπησε και χύνονται 2 σταγόνες κάθε δευτερόλεπτο. Αν οι 25
σταγόνες έχουν μάζα 1,5 g, να βρεθεί η μάζα του νερού που χάνεται κάθε ώρα,
σε κιλά.
\end{exercise}
Κάθε δευτερόλεπτο χάνονται 2 σταγόνες νερού επομένως κάθε ώρα χάνονται:
\begin{lstlisting}
>>> 2* 60 * 60
7200
\end{lstlisting}
Αυτές τις 7200 τις διαιρούμε με το 25 και τις πολλαπλασιάζουμε με τη μάζα των 25 σταγόνων και έχουμε:
\begin{lstlisting}
>>> 7200/25*1.5
432
\end{lstlisting}
Αυτή η μάζα είναι σε γραμμάρια για να βρούμε σε κιλά διαιρούμε με το 1000.
\begin{lstlisting}
>>> 432/1000
0.432
\end{lstlisting}
Μπορούμε να γράψουμε και ένα πρόγραμμα για να υπολογίζει τη μάζα του νερού που χάνεται σε μια πιο γενική περίπτωση. Ας πούμε ότι τα δεδομένα μας θα είναι πόσες σταγόνες χάνονται το δευτερόλεπτο και η μάζα της σταγόνας. Να γραφεί ένα πρόγραμμα που όταν δίνεται η μάζα μιας σταγόνας και το πλήθος των σταγόνων που χύνεται κάθε δευτερόλεπτο, να υπολογίζει τη μάζα του νερού που χύνεται κάθε ώρα σε κιλά.
Το πρόγραμμα θα είναι το εξής:
\begin{lstlisting}
plithos = int(input('Σταγόνες το δευτερόλεπτο:'))
maza = float(input('Μάζα κάθε σταγόνας:'))
grammaria = plithos*maza*60*60
kila = grammaria / 1000
print('Χάνονται ',kila, ' κιλά.')
\end{lstlisting}
Ένα παράδειγμα εκτέλεσης του παραπάνω προγράμματος είναι:
\begin{lstlisting}
Σταγόνες το δευτερόλεπτο:2
Μάζα κάθε σταγόνας:0.05
Χάνονται  0.36  κιλά.
\end{lstlisting}
\begin{exercise}
\sel{67}
Να συμπληρώσεις τα κενά: (α) 23 dm = …………… cm, (β) 3,1 m = …………… Km, (γ) 45,83 cm = …………… m, (δ) 67,2 Κm = …………… mm, (ε) 95,5 mm = …………… cm. 
\end{exercise}
Μπορούμε να φτιάξουμε ένα πρόγραμμα που να λύνει αυτή την άσκηση. Οι μονάδες μέτρησης που μας ενδιαφέρουν είναι:

mm,cm,dm,m,Km

Αν υποθέσουμε ότι ξέρουμε τα χιλιοστά τότε οι υπόλοιπες μονάδες είναι $10$mm, $100$mm, $1000$mm, και $1000000$mm.
Μπορούμε λοιπόν να φτιάξουμε έναν μετατροπέα από χιλιοστά σε οποιδήποτε άλλη μονάδα:
\begin{lstlisting}
def frommmto(num,mon):
    if mon == 'mm':
        return(num)
    elif mon=='cm':
        return(num/10)
    elif mon=='dm':
        return(num/100)
    elif mon=='m':
        return(num/1000)
    elif mon=='Km':
        return(num/1000000)
    else:
        return(None)
\end{lstlisting}
Αντίστοιχα μπορούμε να φτιάξουμε έναν μετατροπέα από οποιαδήποτε μονάδα σε χιλιοστά:
\begin{lstlisting}
def tommfrom(num,mon):
    if mon == 'mm':
        return(num)
    elif mon=='cm':
        return(num*10)
    elif mon=='dm':
        return(num*100)
    elif mon=='m':
        return(num*1000)
    elif mon=='Km':
        return(num*1000000)
    else:
        return(None)
\end{lstlisting}
Συνδυάζοντας αυτούς τους δύο μετατροπείς θα έχουμε έναν μετατροπέα από οποιαδήποτε μονάδα σε οποιαδήποτε:
\begin{lstlisting}
changeUnit(num,arx_mon,tel_mon):
    mms = tommfrom(num,arx_mon)
    if mms is not None:
        result = frommmto(mms,tel_mon)
        return(result)
    else:
        return(None)
\end{lstlisting}
Και ένα πρόγραμμα για δοκιμή είναι:
\begin{lstlisting}
changeUnit(23,'dm','cm')
changeUnit(3.1,'m','Km')
changeUnit(45.83,'cm','m')
changeUnit(67.2,'Km','mm')
changeUnit(95.5,'mm','cm')
\end{lstlisting}
και το αποτέλεσμα είναι:
\begin{lstlisting}
230.0
0.0031
0.45829999999999993
67200000.0
9.55
\end{lstlisting}
\begin{exercise}
Ένα ορθογώνιο παραλληλεπίπεδο έχει ακμές μήκους α = 3,1 m, β = 4,2 m και γ= 2,3 m. Να υπολογίσεις το μήκος των ακμών του σε mm και να το γράψεις σε τυποποιημένη μορφή.
\end{exercise}
Χρησιμοποιώντας την ίδια συνάρτηση όπως και παραπάνω μπορούμε να γράψουμε:
\begin{lstlisting}
>>> mikos = changeUnit(3.1+4.2+2.3,'m','mm')
>>> mikos
9600.000000000002
>>> '{:.2e}'.format(mikos)
'9.60e+03'
\end{lstlisting}
\begin{exercise}
\sel[3]{67}
Γράψε τα παρακάτω μήκη σε αύξουσα σειρά: 986 m, 0,023 Κm, 456 cm, 678 dm.
\end{exercise}
Μπορούμε να χρησιμοποιήσουμε τη συνάρτηση tommfrom από παραπάνω ώστε να γίνουν πρώτα όλα ίδιες μονάδες για να συγκριθούν.
\begin{lstlisting}
a = [(986,'m'),(0.023,'Km'),(456,'cm'),(678,'dm')]
print(sorted(a,key=lambda x:tommfrom(x[0],x[1])))
\end{lstlisting}
Η έκφραση lambda x:tommfrom(x[0],x[1]) είναι μια σύντομη μορφή του εξής:
\begin{lstlisting}
def onoma_sinartisis(x):
    return(tommfrom(x[0],x[1]))
\end{lstlisting}
Το όνομα της συνάρτησης δεν παίζει ρόλο.
Αυτό που συμβαίνει είναι ότι η Python ταξινομεί τα αντικείμενα της λίστας με βάση ένα κλειδί, το κλειδί είναι να μετατρέπει το αντικείμενο σε χιλιοστά χρησιμοποιώντας το πρώτο κομμάτι του αντικειμένου σαν αριθμό και το δεύτερο σαν μονάδα.
\begin{lstlisting}
[(456, 'cm'), (0.023, 'Km'), (678, 'dm'), (986, 'm')]
\end{lstlisting}
\begin{exercise}
\sel[4]{67}
Ένα ορθογώνιο παραλληλόγραμμο έχει διαστάσεις πλευρών α=23 cm και β=45 cm.
Nα βρεις το εμβαδόν του, σε cm$^2$ και σε mm$^2$.
\end{exercise}
Μπορούμε να τη λύσουμε στο REPL ως εξής:
\begin{lstlisting}
>>> emvadosecm2 = 23*45
>>> emvadosecm2
1035
>>> emvadosecm2*100
103500
\end{lstlisting}
\begin{exercise}
\sel[5]{67}
Συμπλήρωσε τα κενά:
(α) 56 Km$^2$=.......m$^2$, (β) 0,987 στρέμματα=.......m$^2$, (γ) 350 στρέμματα=.......m$^2$.
\end{exercise}
Στο REPL:
\begin{lstlisting}
>>> 56 * 1000000
56000000
>>> 0.987 * 1000
987
>>> 350 * 1000
350000
\end{lstlisting}
(α) 56 Km$^2$=56000000m$^2$, (β) 0,987 στρέμματα=987m$^2$, (γ) 350 στρέμματα=350000m$^2$.
\begin{exercise}
\sel[6]{67}
Ένα οικόπεδο έχει σχήμα τετραγώνου με πλευρά 210 m. Να υπολογίσεις το εμβαδόν
του σε m$^2$ και σε στρέμματα.
\end{exercise}
\begin{lstlisting}
>>> emvado = 210*210
>>> emvado
44100
>>> emvado / 1000
44.1
\end{lstlisting}
\begin{exercise}
\sel[7]{67}
Μια αυλή, σχήματος ορθογωνίου παραλληλογράμμου, έχει διαστάσεις 5 m και 7,2 m. Θέλουμε
να τη στρώσουμε, με τετράγωνες πλάκες, πλευράς 40 cm.Πόσες πλάκες θα χρειαστούμε;
\end{exercise}
\begin{lstlisting}
>>> emvadoorth = 5*7.2
>>> emvadoplakas = 0,4*0,4
>>> emvadoorth/emvadoplakas
224.99999999999994
\end{lstlisting}
Δηλαδή περίπου 225 πλάκες.
\begin{exercise}
\sel[8]{67}
Ο όγκος ενός στερεού είναι 15 dm$^3$ 29 cm$^3$. Να βρεις τον όγκο του στερεού σε cm$^3$, m$^3$ και mm$^3$.
\end{exercise}
\begin{lstlisting}
>>> 15 * 100** 3 + 29 * 10 **3
15029000
>>> 15029000 / 1000
15029
>>> 15029/ 100**3
0.01529
\end{lstlisting}
\begin{exercise}
\sel[9]{67}
Ένας οινοπαραγωγός έχει αποθηκεύσει το κρασί του σε 3 ίσες δεξαμενές, σχήματος
ορθογωνίου παραλληλεπιπέδου, με διαστάσεις 3 m, 2 m και 5 m.
Aν πουλήσει το κρασί του προς 4 ευρώ το λίτρο, πόσα χρήματα θα εισπράξει;
\end{exercise}
\begin{lstlisting}
>>> 3 * 3 * 2 *5 
90
>>> 90 * 10 **3
90000
>>> 90000 * 4
360000
\end{lstlisting}
\begin{exercise}
\sel[10]{67}
Να υπολογίσεις τον χρόνο, από τις 8h 10min το πρωί, ως τις 5h 20min το απόγευμα.
\end{exercise}
\begin{lstlisting}
>>> 20 - 10
10
>>> 17 - 8
9
\end{lstlisting}
Άρα 9h και 10min.
H Python μπορεί να κάνει την πράξη χρησιμοποιώντας το module datetime. 
\begin{lstlisting}
>>> import datetime
>>> t1str = '2015-08-12 08:10'
>>> t1 = datetime.datetime.strptime(t1str, '%Y-%m-%d %H:%M')
>>> t2str = '2015-08-12 17:20'
>>> t2 = datetime.datetime.strptime(t2str, '%Y-%m-%d %H:%M')
>>> print(t2-t1)
9:10:00
\end{lstlisting}
\begin{exercise}
\sel[11]{67}
Συμπλήρωσε τα κενά: (α) 4h 52min=.......min=.......s, (β) 3h 12min=......min=.......s,
(γ) 5h 20min 30s=.......min=.......s, (δ) 56min 45s=.......min=.......s
\end{exercise}
Γι' αυτή την άσκηση θα φτιάξουμε ένα πρόγραμμα ώστε να ζητάμε από τον χρήστη ώρες λεπτά και δευτερόλεπτα και να μας μετατρέπει το χρόνο σε λεπτά και σε δευτερόλεπτα.
\begin{lstlisting}
def xronosseld(wres,lepta,deutera):
    xronossedeutera = wres * 60 * 60 + lepta * 60 + deutera
    xronosselepta = xronossedeutera / 60
    print(xronosselepta,' min=',xronossedeutera,' s')

while True:
    wres = int(input('Ώρες:'))
    lepta = int(input('Λεπτα:'))
    deutera = int(input('Δευτερόλεπτα:'))
    xronosseld(wres,lepta,deutera)
\end{lstlisting}

Όταν εκτελέσουμε το παραπάνω πρόγραμμα θα έχουμε το εξής αποτέλεσμα:
\begin{lstlisting}
 Ώρες:4
 Λεπτα:52
 Δευτερόλεπτα:0
 292.0  min= 17520  s
 Ώρες:3
 Λεπτα:12
 Δευτερόλεπτα:0
 192.0  min= 11520  s
 Ώρες:5
 Λεπτα:20
 Δευτερόλεπτα:30
 320.5  min= 19230  s
 Ώρες:0
 Λεπτα:56
 Δευτερόλεπτα:45
 56.75  min= 3405  s
 Ώρες:^C
 \end{lstlisting}
Επειδή έχουμε βάλει \lstinline{while True} η επανάληψη γίνεται για πάντα. Για να βγούμε από το πρόγραμμα θα πατήσουμε το πλήκτρο Ctrl και το πλήκτρο C (\^C).
\begin{exercise}
\sel[12]{67}
Να υπολογίσεις: (α) το $\frac{1}{10}$ της ώρας, (β) το $\frac{1}{5}$ της ώρας, (γ) το $\frac{1}{6}$ της ώρας.
\end{exercise}
\begin{lstlisting}
>>> 1/10*60
6
>>> 1/5*60
12
>>> 1/6*60
10
\end{lstlisting}
Άρα είναι 6 λεπτά, 12 λεπτά και 10 λεπτά.

\begin{exercise}
\sel[13]{68}
Διαθέτουμε σταθμά των 50 g, 500 g και δύο σταθμά του 1 Κg. Πώς θα ζυγίσουμε
ένα βάρος (α) 3 Κg και 600g και (β) 2 Κg και 450 g.
\end{exercise}
Θα προσπαθήσουμε να γράψουμε ένα πρόγραμμα που να λύνει το πρόβλημα. Τα δεδομένα είναι το βάρος σε κιλά και γραμμάρια και μια λίστα με τα σταθμά. Στη συνέχεια μετατρέπουμε το βάρος που δίνεται σε κιλά και γραμμάρια αποκλειστικά σε γραμμάρια. Ξεκινάμε από το μεγαλύτερο από τα σταθμά και βρίσκουμε πόσες φορές χωράει στο βάρος. Συνεχίζουμε την ίδια διαδικασία με το υπόλοιπο του βάρους και τα υπόλοιπα σταθμά.
\begin{lstlisting}
def zygisi(barosKila,barosg,stathmaseg):
    baros = barosKila * 1000 + barosg
    stathmos = 0
    res = [0]*len(stathmaseg)
    while baros>=stathmaseg[-1]:
        if baros >= stathmaseg[stathmos]:
            res[stathmos]=baros//stathmaseg[stathmos]
            baros = baros % stathmaseg[stathmos]
        stathmos += 1
    return(res)

print(zygisi(3,600,[1000,500,50]))
print(zygisi(2,450,[1000,500,50]))
\end{lstlisting}
Το οποίο δίνει το σωστό αποτέλεσμα:
\begin{lstlisting}
[3, 1, 2]
[2, 0, 9]
\end{lstlisting}

Αυτό το πρόγραμμα έχει ένα μειονέκτημα. Η σωστή του λειτουργία βασίζεται στο να δώσει ο χρήστης τα σταθμά ξεκινώντας από το μεγαλύτερο προς το μικρότερο. Δες τι θα συμβεί αν εκτελέσουμε:
\begin{lstlisting}
print(zygisi(3,600,[1000,50,500]))
print(zygisi(2,450,[50,500,100]))
\end{lstlisting}
\begin{lstlisting}
[3, 12, 0]
[49, 0, 0]
\end{lstlisting}
Μπορείς να το αποφύγεις με κάποιες αλλαγές στον κώδικα. Η βασική αλλαγή είναι πως αντί να ελέγχεις το stathmaseg[stathmos] βασιζόμενος ότι αυτό θα είναι το μεγαλύτερο να ελέγχεις με το max(stathmaseg). Θα πρέπει όμως μετά να βάλεις το αποτέλεσμα στη σωστή θέση. Η θέση αυτή είναι stathmaseg.index(max(stathmaseg)). Όμως θα πρέπει να διαγράφουμε κάθε φορά το μεγαλύτερο στοιχείο ώστε η max να μην το ξαναεπιστρέψει. Για αυτό θα χρειαστεί να κάνουμε ένα αντίγραφο της λίστας πάνω στο οποίο δουλεύουμε χωρίς να πειράξουμε το stathmaseg. Συνολικά:
\begin{lstlisting}
def zygisi(barosKila,barosg,stathmaseg):
    baros = barosKila * 1000 + barosg
    stathmos = 0
    res = [0]*len(stathmaseg)
    s = list(stathmaseg)
    while baros>=min(s):
        if baros >= max(s):
            res[stathmaseg.index(max(s))]=baros//max(s)
            baros = baros % max(s)
        s.pop(s.index(max(s)))
        if not s:
            break
    return(res)

print(zygisi(3,600,[1000,50,500]))
print(zygisi(2,450,[50,500,1000]))
\end{lstlisting}
Με αυτόν τον τρόπο έχεις το σωστό αποτέλεσμα που είναι:
\begin{lstlisting}
[3, 2, 1]
[9, 0, 2]
\end{lstlisting}
\begin{exercise}
\sel[14]{68}
Πώς θα ζυγίσουμε (α) ένα σώμα μάζας 5 Κg, με σταθμά των 9 Κg, 3 Κg και 1 Κg (β) ένα σώμα μάζας 3 Κg, με σταθμά 10 Κg, 5 Κg και 1 Κg. 
\end{exercise}
\begin{lstlisting}
>>> 9 == 3 + 1 + 5
True
>>> 10 == 3 + 5 + 2*1
True
\end{lstlisting}
Έτσι μπορούμε να βάλουμε στη μία πλευρά της ζυγαριάς τα 9Kg και στην άλλη όλα τα υπόλοιπα βάρη, μαζί με αυτό που θέλουμε να ζυγίσουμε.
Για το δεύτερο μπορούμε να βάλουμε στη μία πλευρά της ζυγαριάς τα 10Kg και στην άλλη όλα τα υπόλοιπα βάρη τότε θα προκύψει 3+5+1, 9 κιλά βάρος οπότε χρειάζεται να βάλουμε ένα ακόμη βάρος του 1Kg.
Εναλλακτικά μπορούμε να χρησιμοποιήσουμε την παραπάνω συνάρτηση τη zygisi και θα έχουμε
\begin{lstlisting}
>>> print(zygisi(5,0,[3000,1000]))
[1,2]
>>> print(zygisi(3,0,[1000]))
[3]
\end{lstlisting}
επειδή η λογική της zygisis είναι να ζυγίζει με σταθμά μικρότερα του ζητούμενου βάρους.
\begin{exercise}
\sel[15]{68}
Διαθέτουμε τρία δοχεία που χωράνε 2 lt, 0,5 lt και 0,1 lt. Πώς θα μετρήσουμε ένα υγρό, όγκου (α) 5 lt, (β) 2,8 lt, (γ) 2,4 lt. 
\end{exercise}
Η λογική είναι ίδια με τη ζύγιση πιο πάνω:
\begin{lstlisting}
>>> zygisi(5,0,[2000,500,100])
[2, 2, 0]
>>> zygisi(2,800,[2000,500,100])
[1, 1, 3]
>>> zygisi(2,400,[2000,500,100])
[1, 0, 4]
\end{lstlisting}
Δουλεύει επειδή δεν έχει σημασία αν μιλάμε για Kg και g ή για lt και ml αφού η σχέση μεταξύ τους είναι η ίδια.
Ωστόσο θα ήταν καλύτερα να μετατρέψουμε τη zygisi σε metrisi ως εξής:
\begin{lstlisting}
def metrisi(lt,doxeia):
    lt = lt * 1000
    doxeio = 0
    res = [0]*len(doxeia)
    s = list(doxeia)
    while lt>=min(s):
        if lt >= max(s):
            res[doxeia.index(max(s))]=int(lt//max(s))
            lt = lt % max(s)
        s.pop(s.index(max(s)))
        if not s:
            break
    return(res)
\end{lstlisting}
και τότε μπορούμε να γράψουμε:
\begin{lstlisting}
>>> metrisi(5,[2000,500,100])
[2, 2, 0]
>>> metrisi(2.8,[2000,500,100])
[1, 1, 3]
>>> metrisi(2.4,[2000,500,100])
[1, 0, 4]
\end{lstlisting}
\begin{exercise}
\sel[16]{68}
Σε μια πολυκατοικία θέλουν να κατασκευάσουν μια δεξαμενή που να χωράει 3 t πετρέλαιο και να έχει μήκος 2,5 m και πλάτος 1 m. Αν γνωρίζεις ότι ο 1 t πετρελαίου έχει όγκο 1200 lt, υπολόγισε το ύψος της δεξαμενής και πόσα lt πετρελαίου αντιστοιχούν σε κάθε cm ύψους;
\end{exercise}
Εδώ έχουμε το εξής:
\begin{eqnarray}
\textrm{μήκος}\cdot\textrm{πλάτος}\cdot\textrm{ύψος} & = 3t \\
25 \cdot 10 \cdot \textrm{ύψος}& = 3\cdot 1200\textrm{lt}\\
\textrm{ύψος} &= \frac{3600}{25\cdot 10}\\
\end{eqnarray}
\begin{lstlisting}
>>> 3600/ (25*10)
14.4
\end{lstlisting}
Τα 14.4 είναι δεκατόμετρα οπότε η δεξαμενή έχει ύψος 1.44m ή αλλιώς 144cm. Κάθε εκατοστό ύψους έχει όγκο:
\begin{lstlisting}
>>> 3600/144
25
\end{lstlisting}
Οπότε κάθε εκατοστό ύψους συνεισφέρει 25lt στον όγκο.
\begin{exercise}
\sel[17]{68}
Μια δεξαμενή έχει σχήμα ορθογωνίου παραλληλεπιπέδου με ύψος 1,2 m και βάση τετράγωνο πλευράς 80 cm. Μια αντλία αδειάζει από την δεξαμενή 8 lt το λεπτό. Να βρεθεί: (α) σε πόσο χρόνο η στάθμη του νερού θα κατέβει κατά 10 cm, (β) σε πόσο χρόνο θα αδειάσει η δεξαμενή και (γ) πόσο θα κατέβει η στάθμη του νερού σε μισή ώρα
\end{exercise}
Θα κάνουμε τους υπολογισμούς σε dm. 
α) Τα 10cm εκατοστά ύψους έχουν όγκο:
\begin{lstlisting}
>>> ogkos10cm = 8 * 8
>>> ogkos10cm
64
>>> 64/8
8
\end{lstlisting}
Άρα 8 λεπτά
β)
Ο συνολικός όγκος είναι:
\begin{lstlisting}
>>> ogkos = 12 * 8 * 8
>>> ogkos
768
>>> ogkos / 8
96.0
\end{lstlisting}
Η δεξαμενή θα αδειάσει σε 96 λεπτά.
γ) Σε μισή ώρα η δεξαμενή θα χάσει
\begin{lstlisting}
>>> 30*8
240
>>> 240 / (8*8)
3.75
\end{lstlisting}
τα 3,75 είναι δεκατόμετρα δηλαδή θα αδειάσει κατά 37,5 εκατοστά.
\begin{exercise}
\sel[18]{68}
Ένας ποδηλάτης διήνυσε μια απόσταση σε χρόνο 1h 15 min, ενώ ένας δεύτερος διήνυσε την ίδια απόσταση σε χρόνο 1h 45min. (α) Ποιο μέρος του χρόνου του δεύτερου είναι ο χρόνος του πρώτου ποδηλάτη; (β) Ποιο μέρος του χρόνου του πρώτου είναι ο χρόνος του δεύτερου ποδηλάτη; Τι παρατηρείς; 
\end{exercise}
\begin{lstlisting}
from fractions import Fraction
def fractionTime(h1,m1,h2,m2):
  t1 = h1*60 + m1
  t2 = h2*60 + m2
  return(Fraction(t1,t2))

print(fractionTime(1,15,1,45))
print(fractionTime(1,45,1,15))
\end{lstlisting}
και η απάντηση είναι:
\begin{lstlisting}
5/7
7/5
\end{lstlisting}
Παρατηρούμε ότι τα κλάσματα είναι αντίστροφα.
\begin{exercise}
\sel[4]{70}
Το εμβαδό του ορθογωνίου είναι $\frac{3}{4}$
\end{exercise}
\begin{lstlisting}
>>> (2+1/2+1/2)*1/4
0.75
>>> 3/4
0.75
\end{lstlisting}
Άρα Σωστό
\begin{exercise}
\sel[7]{70}
Το κλάσμα:
$$\frac{1\frac{5}{8}}{3}$$
\end{exercise}
\begin{lstlisting}
>>> (1+5/8)/3
0.5416666666666666
>>> 5/40
0.125
\end{lstlisting}
Άρα Λάθος
\begin{exercise}
\sel[10]{70}
$$\frac{5}{8}=\frac{625}{1000}=\frac{35}{56}=\frac{1250}{2000}=0,625$$
\end{exercise}
\begin{lstlisting}
>>> 5/8
0.625
>>> 625/1000
0.625
>>> 35/56
0.625
>>> 1250/2000
0.625
\end{lstlisting}
Άρα Σωστό
\begin{exercise}
\sel[11]{70}
$$2+\frac{1}{10}+\frac{3}{100}+\frac{45}{1000} = 2,175$$
\end{exercise}
\begin{lstlisting}
>>> 2+1/10+3/100+45/1000
2.175
\end{lstlisting}
Άρα Σωστό
\begin{exercise}
\sel[12]{70}
Οι αριθμοί $7,2$ και $\frac{5}{36}$ είναι αντίστροφοι.
\end{exercise}
\begin{lstlisting}
>>> 7.2*5/36
1.0
\end{lstlisting}
Άρα Σωστό
\begin{exercise}
\sel[14]{70}
$$\frac{149}{231}>\frac{220}{452}$$
\end{exercise}
\begin{lstlisting}
>>> 149/231>220/452
True
\end{lstlisting}
\begin{exercise}
\sel[15]{70}
$$\frac{1050}{3100}>\frac{2593}{4650}$$
\end{exercise}
\begin{lstlisting}
>>> 1050/3100>2593/4650
False
\end{lstlisting}
\begin{exercise}
\sel[16]{70}
$$\frac{3,4}{7,3} = 0,4659$$
\end{exercise}
\begin{lstlisting}
>>> 3.4/7.3
0.4657534246575342
\end{lstlisting}
Άρα Λάθος
\begin{exercise}
\sel[17]{70}
$$\frac{1,028}{1,2} = 0,856666\ldots$$
\end{exercise}
\begin{lstlisting}
>>> 1.028/1.2
0.8566666666666667
\end{lstlisting}
Άρα Σωστό, αν και ο υπολογιστής κάνει προσέγγιση αφού δεν μπορεί να έχει άπειρα ψηφία.
\begin{exercise}
\sel[18]{70}
$$\frac{34,5}{5,7} = 5,7$$
\end{exercise}
\begin{lstlisting}
>>> 34.5/5.7
6.052631578947368
\end{lstlisting}
Άρα Λάθος
\begin{exercise}
\sel[19]{70}
$$\frac{1,25}{1,85} = 0,675675675\ldots$$
\end{exercise}
\begin{lstlisting}
>>> 1.25/1.85
0.6756756756756757
\end{lstlisting}
\begin{exercise}
\sel[20]{70}
$$\frac{0,69}{4,6}=0,15$$
\end{exercise}
\begin{lstlisting}
>>> 0.69/4.16
0.1658653846153846
\end{lstlisting}
\begin{exercise}
\sel[21]{70}
Αν $\frac{x}{3} = 7$ το $x$ είναι ο αριθμός 23
\end{exercise}
\begin{lstlisting}
>>> 3*7
21
\end{lstlisting}

\chapter{Δεκαδικοί αριθμοί}
\section{Εισαγωγή}
Αν χωρίσουμε τη μονάδα σε 10 ίσα μέρη τότε μπορούμε να πάρουμε κλάσματα της μονάδας όπως $\frac{3}{10}$, $\frac{5}{10}$ κλπ. Τα κλάσματα είναι ομώνυμα συγκρίνονται εύκολα και βοηθάνε στις πράξεις. 
Γενικότερα, ονομάζουμε δεκαδικό κλάσμα οποιδήποτε κλάσμα έχει παρονομαστή μια δύναμη του 10. Κάθε δεκαδικό κλάσμα γράφεται σαν δεκαδικός αριθμός με τόσα δεκαδικά ψηφία όσα μηδενικά έχει ο παρονομαστής του.
Η Python χειρίζεται τους δεκαδικούς αριθμούς όπως και τους υπόλοιπους.
Δοκίμασε:
\begin{lstlisting}
>>> 0.3 + 0.5
0.8
>>> type(0.7)
<class 'float'>
\end{lstlisting}

Βλέπουμε ότι οι δεκαδικοί αριθμοί δεν είναι int, όπως οι ακέραιο αλλά float. Το όνομα float έχει να κάνει με τον τρόπο με τον οποίο ο υπολογιστής αποθηκεύει αποδοτικά αυτούς τους αριθμούς. 

Ας συνδυάσουμε τις γνώσεις από τα κλάσματα με τα κλάσματα που μάθαμε στο προηγούμενο κεφάλαιο.
\begin{lstlisting}
>>> from fractions import Fraction
>>> x = Fraction(3,10)
>>> float(x)
0.3
\end{lstlisting}

Το \lstinline{Fraction(3,10)} εννοεί το κλάσμα $\frac{3}{10}$ που είναι ίσο με 0,3. Όμως στην Python το 0,3 θα το γράφουμε με 0.3. Με τη συνάρτηση float μετατρέπουμε το $\frac{3}{10}$ σε δεκαδικό αριθμό.

\begin{exercise}
\sel{56} Γράψτε τους αριθμούς $\frac{3}{10}$, $\frac{825}{1000}$, $\frac{53}{1000}$, $\frac{1004}{10000}$.
\end{exercise}
\begin{lstlisting}
>>> float(Fraction(3,10))
0.625
>>> float(Fraction(825,100))
8.25
>>> float(Fraction(53,1000))
0.053
>>> float(Fraction(1004,10000))
0.1004
\end{lstlisting}

Η Python μπορεί να μετατρέψει τα κλάσματα σε δεκαδικό αριθμό ανεξάρτητα από τον παρονομαστή.
\begin{exercise}
\sel{59} Γράψε καθένα από τα παρακάτω κλάσματα, ως δεκαδικό αριθμό: (i) με προσέγγιση
εκατοστού και (ii) με προσέγγιση χιλιοστού: 

(α) $\frac{7}{16}$

(β) $\frac{21}{17}$

(γ) $\frac{20}{95}$
\end{exercise}
\begin{lstlisting}
>>> x = Fraction(7,16)
>>> float(x)
0.4375
>>> round(float(x),2)
0.44
>>> round(float(x),3)
0.438
>>> x = Fraction(21,17)
>>> float(x)
1.2352941176470589
>>> round(float(x),2)
1.24
>>> round(float(x),3)
1.235
>>> x = Fraction(20,95)
>>> float(x)
0.21052631578947367
>>> round(float(x),2)
0.21
>>> round(float(x),3)
0.211
\end{lstlisting}


Η στρογγυλοποίηση των δεκαδικών υλοποιείται στην Python με τη συνάρτηση round. Οπότε μπορείς να στρογγυλοποιήσεις εύκολα δεκαδικούς αριθμούς ως εξής:
\begin{exercise}
Να στρογγυλοποιήσεις τους παρακάτω δεκαδικούς αριθμούς στο δέκατο, εκατοστό και
χιλιοστό: 

(α) 9876,008, 

(β) 67,8956, 

(γ) 0,001, 

(δ) 8,239, 

(ε) 23,7048.
\end{exercise}
Θυμόμαστε να αλλάζουμε την υποδιαστολή από κόμμα σε τελεία:
\begin{lstlisting}
def roundall(x):
    print(round(x,1))
    print(round(x,2))
    print(round(x,3))

roundall(9876.008)
roundall(67.8956)
roundall(0.001)
roundall(8.239)
roundall(23.7048)
\end{lstlisting}

To αποτέλεσμα είναι:
\begin{lstlisting}
67.9
67.9
67.896
0.0
0.0
0.001
8.2
8.24
8.239
23.7
23.7
23.705
\end{lstlisting}

\begin{exercise}
\sel{59} Στον αριθμό $34,\square\square\square$ λείπουν τα τελευταία τρία ψηφία του. Να συμπληρώσεις τον
αριθμό με τα ψηφία 9, 5 και 2, έτσι ώστε κάθε ψηφίο να γράφεται μία μόνο φορά. Να γράψεις όλους τους δεκαδικούς που μπορείς να βρεις και να τους διατάξεις σε φθίνουσα σειρά.
\end{exercise}

Πώς μπορεί η Python να βρει όλους τους πιθανούς συνδυασμούς του 9,5,2;
Δοκίμασε τη βιβλιοθήκη itertools και συγκεκριμένα τη συνάρτηση permutations.
\begin{lstlisting}
>>> from itertools import permutations
>>> x = permutations([1,2,3])
>>> print(x)
<itertools.permutations object at 0x012BE1B0>
>>> print(list(x))
[(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]
\end{lstlisting}
Έτσι με την permutations μπορείς να βρεις όλες τις αναδιατάξεις των αριθμών. Οπότε τώρα το πρόγραμμα μπορεί να γίνει ως εξής:
\begin{lstlisting}
lista = []
from itertools import permutations
for p in permutations([9,5,2]):
    lista.append(34+p[0]/10+p[1]/100+p[2]/1000)
print(lista)
\end{lstlisting}
Που δίνει το αποτέλεσμα:
\begin{lstlisting}
[34.952, 34.925000000000004, 34.592000000000006, 34.529, 
34.29500000000001, 34.259]
\end{lstlisting}
Τα ψηφία που εμφανίζονται στο τέλος των αριθμών προκύπτουν από την αναπαράσταση των δεκαδικών στον υπολογιστή που υπόκειται σε κάποιους περιορισμούς.
Αν δεν θέλουμε να εμφανίζονται μπορούμε να αλλάξουμε το for σε:
\begin{lstlisting}
for p in permutations([9,5,2]):
    ar = 34+p[0]/10+p[1]/100+p[2]/1000
    lista.append(round(ar,3))
\end{lstlisting}
Τώρα για να γράψουμε τους αριθμούς με φθίνουσα σειρά θα δοκιμάσουμε τη sorted. Η sorted ταξινομεί τους αριθμούς που δίνονται σε μια λίστα. Δοκίμασε:
\begin{lstlisting}
>>> sorted([4,2,3])
[2, 3, 4]
\end{lstlisting}
Έτσι το συνολικό πρόγραμμα γίνεται:
\begin{lstlisting}
lista = []
from itertools import permutations
for p in permutations([9,5,2]):
    ar = 34+p[0]/10+p[1]/100+p[2]/1000
    lista.append(round(ar,3))
print(sorted(lista))
\end{lstlisting}

Που δίνει το αποτέλεσμα:
\begin{lstlisting}
[34.259, 34.295, 34.529, 34.592, 34.925, 34.952]
\end{lstlisting}

Όμως η άσκηση μας ζητάει να τυπώσουμε τη λίστα με φθίνουσα σειρά. Αυτό μπορεί να γίνει δηλώνοντας στη sorted ότι θέλουμε αντίστροφη σειρά γράφοντας \lstinline{reverse=True}. Το τελικό πρόγραμμα είναι το εξής:
\begin{lstlisting}
lista = []
from itertools import permutations
for p in permutations([9,5,2]):
    ar = 34+p[0]/10+p[1]/100+p[2]/1000
    lista.append(round(ar,3))
print(sorted(lista,reverse=True))
\end{lstlisting}

Μια μικρή τροποποίηση που μπορεί να γίνει για να εμφανιστούν οι αριθμοί σε διαφορετικές γραμμές είναι να τυπώσουμε τη λίστα με μια for.
\begin{lstlisting}
lista = []
from itertools import permutations
for p in permutations([9,5,2]):
    ar = 34+p[0]/10+p[1]/100+p[2]/1000
    lista.append(round(ar,3))

for x in sorted(lista,reverse=True):
    print(x)
\end{lstlisting}

\begin{exercise}
\sel{61} Να υπολογίσεις τα αθροίσματα:

(α) $48,18 + 3,256 + 7,129$

(β) $3,59 + 7,13 + 8,195$
\end{exercise}

\begin{lstlisting}
>>> 48.18+3.256+7.129
58.565
>>> 3.59 + 7.13 + 8.195
18.915
\end{lstlisting}
\begin{exercise}
\sel{61}
Να υπολογίσεις το μήκος της περιμέτρου των οικοπέδων:
(Σχήμα ---)
\end{exercise}
\begin{lstlisting}
>>> 26.14 + 80.19 + 29.13+38.13+23.24+57.89+80.19
334.91
>>> 39.93+80.19+57.89+47.73+44.75+48.9+47.19
366.58
\end{lstlisting}
\begin{exercise}
\sel{61} Να κάνεις τις διαρέσεις:
(α) $579:48$

(β) $314:25$

(γ) $520:5,14$

(δ) $49,35:7$

\end{exercise}
\begin{lstlisting}
>>> 579/48
12.0625
>>> 314/25
12.56
>>> 520/5.14
101.16731517509729
>>> 49.35/7
7.05
\end{lstlisting}
\begin{exercise}
\sel{61}
Να κάνεις τις πράξεις: 

(α) $520 \cdot 0,1 + 0,32 \cdot 100 $

(β) $4,91 \cdot 0,01 + 0,819 \cdot 10$

\end{exercise}

\begin{lstlisting}
>>> 520*0.1 + 0.32*100
84.0
>>> 4.91*0.01 + 0.819*10
8.239099999999999
\end
\end{lstlisting}

Σε αυτή την άσκηση βλέπουμε ότι ο υπολογιστής προσεγγίζει τα αποτελέσματα με τον δικό του τρόπο.
Δοκίμασε:
\begin{lstlisting}
>>> x = 520*0.1 + 0.32*100
>>> x
84.0
>>> type(x)
<class 'float'>
>>> y = int(x)
>>> type(y)
<class 'int'>
>>> x == y
True
\end{lstlisting}
Αυτό σημαίνει πως ο ακέραιος αριθμός 84, και κάθε ακέραιος, στην Python μπορεί να αναπαρασταθεί σαν ακέραιος αλλά και σαν float με μηδενικά δεκαδικά ψηφία.
Στην δεύτερη πράξη παρατηρούμε ότι αντί για το σωστό αποτέλεσμα που είναι $0,0491+8,19=8,2391$ η Python εμφανίζει μια προσέγγιση που είναι $8.239099999999999$. Η διαφορά είναι πολύ μικρή. Ωστόσο οι δύο ποσότητες δεν είναι ίσες.
Δοκίμασε:
\begin{lstlisting}
>>> 4.91*0.01 + 0.819*10 == 8.2391
False
>>> 8.2391 - 4.91*0.01 + 0.819*10 
1.7763568394002505e-15
\end{lstlisting}
Ο αριθμός \lstinline{1.7763568394002505e-15} σημαίνει πως η διαφορά είναι περίπου $1.77\cot 10^{-15}$ που είναι πάρα πολύ μικρή και προκύπτει από τον τρόπο με τον οποίο η Python αποθηκεύει τους αριθμούς.

\begin{exercise}
\sel{61}
Να κάνεις τις πράξεις:

(α) $4,7:0,1-45:10$

(β) $0,98:0,0001 - 6785:1000$
\end{exercise}

\begin{lstlisting}
>>> 4.7/0.1 - 45/10
42.5
>>> 0.98/0.0001 - 6785/1000
9793.215
\end{lstlisting}
Βλέπουμε ότι η Python υπολογίζει σωστά πρώτα τη διαίρεση και μετά την αφαίρεση.

\begin{exercise}
\sel{61}
Η περίμετρος ενός τετραγώνου είναι 20,2. Να υπολογίσεις την πλευρά του.
\end{exercise}
\begin{lstlisting}
>>> 20.2/4
5.05
\end{lstlisting}

\begin{exercise}
\sel{61}
Η περίμετρος ενός ισοσκελούς τριγώνου είναι 48,52. Αν η βάση του είναι 10,7, πόσο είναι η κάθε μία από τις ίσες πλευρές του;
\end{exercise}
Αφαιρούμε πρώτα από το 48,52 το 10,7. Το αποτελέσμα το διαιρούμε με το δυο.
\begin{lstlisting}
>>> 48.52-10.7
37.82000000000001
>>> 37.82/2
18.91
\end{lstlisting}

\begin{exercise}
\sel{61}
Να υπολογίσεις τις τιμές των αριθμητικών παραστάσεων:

(α) $24\cdot 5 - 2 + 3 \cdot 5$

(β) $3\cdot 11 -2 + 45,1 : 2$
\end{exercise}
\begin{lstlisting}
>>> 24*5 - 2 +3*5
133
>>> 3*11 - 2 + 54.1/2
58.05
\end{lstlisting}

\begin{exercise}
\sel{61}
Να υπολογίσεις τις δυνάμεις:
(α) $3,1^2$, (β) $7,01^2$, (γ) $4,5^2$, (δ) $0,5^2$, (ε) $0,2^2$, (στ) $0,3^3$
\end{exercise}
\begin{lstlisting}
>>> 3.1**2
9.610000000000001
>>> 7.01**2
49.1401
>>> 4.5**2
20.25
>>> 0.5**2
0.25
>>> 0.2**2
0.04000000000000001
>>> 0.3*3
0.8999999999999999
\end{lstlisting}
Πάλι κάνουν την εμφάνισή τους μικρές προσεγγίσεις.

\begin{exercise}
Τοποθέτησε ένα ``x'' στην αντίστοιχη θέση (ΣΩΣΤΟ ΛΑΘΟΣ)
(α) $2,75 + 0,05 + 1,40 + 16,80 = 21$
(β) $420,510 + 72,490 + 45,19 + 11,81 = 500$
(γ) $4 – 3,852 = 1,148$
(δ) $32,01 – 4,001 = 28,01$
(ε) $41900 \cdot 0,0001 – 0,0419 \cdot 1000 = 0$
(στ) $56,89 \cdot 0,01 + 4311 : 10000 = 1$
(ζ) $(3,2 + 7,2 \cdot 2 + 24 \cdot 0,1) : 100 = 0,2$
\end{exercise}

(α)
\begin{lstlisting}
>>> 2.75 + 0.05 + 1.40 + 16.80 == 21
True
>>> 2.75 + 0.05 + 1.40 + 16.80
21.0
\end{lstlisting}
Άρα Σωστό

(β)
\begin{lstlisting}
>>> 420.510 + 72.490 + 45.19 + 11.81 == 500
False
>>> 420.510 + 72.490 + 45.19 + 11.81
550.0
\end{lstlisting}
Άρα Λάθος

(γ)
\begin{lstlisting}
>>> 4 - 3.852 == 1.148
False
>>> 4 - 3.852
0.14800000000000013
\end{lstlisting}
Άρα Λάθος

(δ)
\begin{lstlisting}
>>> 32.01 - 4.001 == 28.01
False
>>> 32.01 - 4.001
28.008999999999997
\end{lstlisting}
Άρα Λάθος

(ε)
\begin{lstlisting}
>>> 41900*0.0001 - 0.0419*1000 == 0
False
>>> 41900*0.0001 - 0.0419*1000
-37.71
\end{lstlisting}
Άρα Λάθος

(στ)
\begin{lstlisting}
>>> 56.89*0.01 + 4311 / 10000 == 1
True
>>> 56.89*0.01 + 4311 / 10000
1.0
\end{lstlisting}
Άρα Σωστό

και 

(ζ)
\begin{lstlisting}
>>> (3.2 + 7.2*2 + 24*0.1) / 100 == 0.2
True
>>> (3.2 + 7.2*2 + 24*0.1) / 100
0.2
\end{lstlisting}

Άρα Σωστό.


\section{Τυποποιημένη μορφή μεγάλων αριθμών}
Η μάζα του Ήλιου είναι 1983000000000000000000000000000 κιλά. Για να διευκολυνθούμε μπορούμε να γράψουμε αυτόν τον αριθμό στην μορφή $\alpha \cdot 10^ν$. Αρχικά μετράμε τα μηδενικά:
$$1983.000.000.000.000.000.000.000.000.000$$
ο αριθμός μας γίνεται:
$$1983\cdot 10^{27}$$
Η τυποποιημένη μορφή απαιτεί το $\alpha$ να είναι μεγαλύτερο ή ίσο του 1 και μικρότερο του 10. Οπότε το 1983 πρέπει να γίνει 1,983 και ο αριθμός μας να γίνει 
$$1,983\cdot 10^{30}$$
σε τυποποιημένη μορφή μεγάλων αριθμών.
Η Python υποστηρίζει την τυποποιημένη μορφή μεγάλων αριθμών με τη χρήση της εντολής format.
Δοκίμασε:
\begin{lstlisting}
>>> x = 1983000000000000000000000000000
>>> print(x)
1983000000000000000000000000000
>>> print('{:.3e}'.format(x))
1.983e+30
\end{lstlisting}
H γενική μορφή είναι να χρησιμοποιείς \lstinline|<'{:.Ne}'.format(x)>|όπου Ν είναι το πλήθος των δεκαδικών ψηφίων που θες να εμφανίζονται. Έτσι
\begin{lstlisting}
>>> print('{:.2e}'.format(3140000000000000000))
3.14e+18
>>> print('{:.2e}'.format(234000000000000000))
2.34e+17
\end{lstlisting}
Η Python καταλαβαίνει την τυποποιημένη μορφή π.χ.:
\begin{lstlisting}
>>> x = 3.14e+30
>>> print(x)
3.14e+30
>>> print('{:.0f}'.format(x))
3139999999999999741556248543232
\end{lstlisting}
To '{:.0f}' σημαίνει πως ο αριθμός θα πρέπει να γραφεί σαν δεκαδικός (float) με μηδεν δεκαδικά ψηφία
\begin{exercise}
\sel{63}
Να γράψεις τους παρακάτω αριθμούς στην τυποποιημένη μορφή:
(α) 583.000 (β) 4.300.000 (γ) 7.960.000 (δ) 3.420.000.000 (ε) 4.800 (στ) 7.310
(ζ) 281.900 (η) 518.000.000 (θ) 131.000 (ι) 675.000.
\end{exercise}
\begin{lstlisting}
>>> print('{:.2e}'.format(583000))
5.83e+05
>>> print('{:.1e}'.format(4300000))
4.3e+06
>>> print('{:.2e}'.format(7960000))
7.96e+06
>>> print('{:.2e}'.format(3420000000))
3.42e+09
>>> print('{:.1e}'.format(4800))
4.8e+03
>>> print('{:.2e}'.format(7310))
7.31e+03
>>> print('{:.3e}'.format(281900))
2.819e+05
>>> print('{:.2e}'.format(518000000))
5.18e+08
>>> print('{:.2e}'.format(131000))
1.31e+05
>>> print('{:.2e}'.format(675000))
6.75e+05
\end{lstlisting}
\begin{exercise}
\sel{63}
Nα γράψεις τη δεκαδική μορφή των αριθμών:
(α) $3,1 \cdot 106$ (β) $4,820 \cdot 105$ (γ) $3,25 \cdot 104$ (δ) $7,4 \cdot 103$ (ε) $9,2 \cdot 102$.
\end{exercise}
\begin{lstlisting}
>>> print(4.820 * 10**5)
482000.0
>>> print(3.25 * 10**4)
32500.0
>>> print(7.4 * 10**3)
7400.0
>>> print(9.2 * 10**2)
919.9999999999999
\end{lstlisting}
Ειδικά για το τελευταίο παρατηρούμε ότι έχουμε μια προσέγγιση και αντί για 920 που είναι το σωστό αποτέλεσμα προκύπτει 919.9999999999999. H Python κάνει προσεγγίσεις όταν χρειάζεται να κάνει πράξεις ή όταν ο αριθμός δεν μπορεί να αναπαρασταθεί στα όρια του υπολογιστή. Το 920 δεν ανήκει στην δεύτερη κατηγορία οπότε το λάθος προκύπτει από την πράξη (πολλαπλασιαμός με το 100). Στην πραγματικότητα ο πολλαπλασιασμός αυτός δεν είναι αναγκαίος μπορείς να γράψεις 9.2e2 αντί για 9.2*10**2 και η Python θα καταλάβει τον αριθμό που θέλεις:
\begin{lstlisting}
>>> 9.2e2
920.0
\end{lstlisting}
\begin{exercise}
Nα εκφραστεί το μήκος των 2.754,389 m, σε όλες τις υποδιαιρέσεις του m.
\end{exercise}
Οι υποδιαιρέσεις του μέτρου (m) είναι τα δεκατόμετρα (dm), τα εκατοστόμετρα (cm) και τα χιλιοστόμετρα (mm).
Για να εκφραστεί το μήκος σε κάθε μία από τις υποδιαιρέσεις θα πρέπει να το πολλαπλασιάζουμε με το 10. 
Δοκίμασε:
\begin{lstlisting}
>>> x = 2754.389
>>> x = 10*x
>>> print(x)
27543.89
>>> x = 10*x
>>> print(x)
275438.9
>>> x = 10*x
>>> print(x)
2754389.0
\end{lstlisting}
Οπότε έχουμε 27543.89 δεκατόμετρα, 275438.9 εκατοστόμετρα και 2754389 χιλιοστόμετρα.
Μπορούμε να μετατρέψουμε τα παραπάνω σε πρόγραμμα ως εξής:
\begin{lstlisting}
x = float(input('Μήκος σε μέτρα:'))
for i in range(3):
    x = 10*x
    print(x)
\end{lstlisting}
Που δίνει το εξής αποτέλεσμα:
\begin{lstlisting}
Μήκος σε μέτρα:2754.389
27543.89
275438.9
2754389.0
\end{lstlisting}
Ακόμη καλύτερα θα ήταν να κάνουμε:
\begin{lstlisting}
x = float(input('Μήκος σε μέτρα:'))
monades = ['dm','cm','mm']
for i in range(3):
    x = 10*x
    print(x,monades[i])
\end{lstlisting}
Αν ξέχασες το float πριν το input θα δεις ότι ο πολλαπλασιασμός μεταξύ ακεραίου και αλφαρηθμιτικού δουλεύει, και αντιγράφει το ίδιο αλφαριθμητικό πολλές φορές, δοκίμασε:
\begin{lstlisting}
>>> x = input('Μήκος σε μέτρα:')
Μήκος σε μέτρα:2754.389
>>> 10*x
'2754.3892754.3892754.3892754.3892754.3892754.3892754.3892754.3892754.3892754.389'
\end{lstlisting}
\begin{exercise} 
Η επιφάνεια ενός κύβου έχει εμβαδόν 96 cm$^2$. Να βρεθεί ο όγκος του.
\end{exercise}
Η λύση του βιβλίου είναι:

Επειδή ο κύβος έχει 6 έδρες, η κάθε έδρα του θα έχει εμβαδόν $96\textrm{cm}^2 : 6 = 16\textrm{cm}^2$.

Αλλά είναι $16\textrm{cm}^2 = 4\textrm{cm} \cdot 4\textrm{cm} = (4\textrm{cm})^2$, άρα, η ακμή του κύβου είναι 4cm.

Επομένως, ο όγκος του κύβου είναι: $(4\textrm{cm})^3 = 4\textrm{cm} \cdot 4\textrm{cm} \cdot 4\textrm{cm} = 64 \textrm{cm}^3$

Σε Python η λύση προχωράει ως εξής:
\begin{lstlisting}
>>> epifaneia = 96
>>> epifaneiaPlevras = epifaneia/6
16
\end{lstlisting}

Εμείς ξέρουμε ότι $4^2=16$ και μπορούμε να το θυμηθούμε. Ο υπολογιστής όμως δεν το ξέρει και πρέπει να έχει μια συνάρτηση για να υπολογίσει τον αριθμό που αν τον υψώσουμε στο τετράγωνο θα κάνει 16. Ευτυχώς, αυτή η συνάρτηση υπάρχει λέγεται sqrt και βρίσκεται στη βιβλιοθήκη math. Οπότε μπορούμε να τη χρησιμοποιήσουμε ως εξής:
\begin{lstlisting}
>>> import math
>>> math.sqrt(16)
4.0
\end{lstlisting}
και από εκεί μπορούμε να υπολογίσουμε τον όγκο υψώνοντας στην τρίτη.

Συνολικά το πρόγραμμά μας γίνεται:
\begin{lstlisting}
import math
epifaneia = 96
epifaneiaPlevras = epifaneia/6
akmi = math.sqrt(epifaneiaPlevras)
ogkos = akmi**3
print(ogkos)
\end{lstlisting}
που δίνει το αποτέλεσμα:
\begin{lstlisting}
64.0
\end{lstlisting}

Το ίδιο πρόγραμμα μπορούμε να το χρησιμοποιήσουμε και για να βρούμε τον όγκο ενός κύβου με επιφάνεια 54. Αφού έχουμε
$54:6=9$ άρα η ακμή του κύβου είναι $3$ και ο όγκος του $27$. Το παρακάτω πρόγραμμα δίνει το σωστό αποτέλεσμα:
\begin{lstlisting}
import math
epifaneia = 54
epifaneiaPlevras = epifaneia/6
akmi = math.sqrt(epifaneiaPlevras)
ogkos = akmi**3
print(ogkos)
\end{lstlisting}

Μπορούμε να γράψουμε ένα πρόγραμμα που να του δίνουμε την επιφάνεια ενός κύβου και να μας βρίσκει τον όγκο του το πρόγραμμα αυτό είναι το εξής:
\begin{lstlisting}
import math
epifaneia = int(input('Δώσε επιφάνεια κύβου: '))
epifaneiaPlevras = epifaneia/6
akmi = math.sqrt(epifaneiaPlevras)
ogkos = akmi**3
print('Ο όγκος του κύβου είναι: ', ogkos)
\end{lstlisting}

Τέλος, μπορούμε να γράψουμε μια συνάρτηση που να υπολογίζει τον όγκο ενός κύβου από την επιφάνειά του:
\begin{lstlisting}
import math
def ogkosapoepifaneia(epifaneia):
    epifaneiaPlevras = epifaneia/6
    akmi = math.sqrt(epifaneiaPlevras)
    ogkos = akmi**3
    return(ogkos)
epifaneia = int(input('Δώσε επιφάνεια κύβου: '))
print('Ο όγκος του κύβου είναι: ', ogkosapoepifaneia(epifaneia))
\end{lstlisting}
    
 

\begin{exercise}
\sel{66}Mια αμαξοστοιχία διανύει την απόσταση Αθήνας -
Πύργου σε 4 ώρες και 57 λεπτά.
Αν η αμαξοστοιχία ξεκινά από την Αθήνα στις 9:10
π.μ. το πρωί, ποια ώρα θα φτάσει στον Πύργο;
\end{exercise}
Πώς μπορούμε στην Python να κάνουμε πράξεις με τις ώρες;  Υπάρχουν δύο τρόποι:
α)
Να τα υπολογίσουμε με όσα γνωρίζουμε:
Έτσι αν έχουμε θέλουμε να προσθέσουμε 9h και 10m με 4h και 57m οπότε ξεκινάμε από τα λεπτά και βρίσκουμε τις ώρες μετά. Ένας τρόπος είναι λοιπόν ο εξής:
\begin{lstlisting}
anaxWra = 9
anaxLepta = 10
diarkeiaWra = 4
diarkeiaLepta = 57
athroismaLepta = anaxLepta + diarkeiaLepta
telikaLepta = athroismaLepta % 60
telikiWra = anaxWra + diarkeiaWra + athroismaLepta // 60
if telikiWra > 12:
    print(str(telikiWra ) + ':' + str(telikaLepta - 12)+ ' μ.μ.')
else:
    print(str(telikiWra)+':'+str(telikaLepta) + 'π.μ.')
\end{lstlisting}

Όπως καταλαβαίνεις το θέμα δεν είναι να υπολογίσεις μια φορά το αποτέλεσμα αλλά να φτιάξεις ένα πρόγραμμα που να υπολογίζει το αποτέλεσμα αν ο χρήστης δίνει την ώρα αναχώρησης και τη διάρκεια του ταξιδιού. Αυτό μπορεί να γίνει με την input και τη split.
\begin{lstlisting}
anax = input('Αναχώρηση (μορφή ωω:λλ)>')
diarkeia = input('Διάρκεια (μορφή ωω:λλ)>')
anaxWra = int(anax.split(':')[0])
anaxLepta = int(anax.split(':')[1])
diarkeiaWra = int(diarkeia.split(':')[0])
diarkeiaLepta = int(diarkeia.split(':')[1])
athroismaLepta = anaxLepta + diarkeiaLepta
telikaLepta = athroismaLepta % 60
telikiWra = anaxWra + diarkeiaWra + athroismaLepta // 60
if telikiWra > 12:
    print(str(telikiWra ) + ':' + str(telikaLepta -12)+ ' μ.μ.')
else:
    print(str(telikiWra)+':'+str(telikaLepta) + 'π.μ.')
\end{lstlisting}

Το παραπάνω πρόγραμμα μας δίνει τη σωστή απάντηση σε πολλές περιπτώσεις. Όχι όμως σε όλες. Δείτε:
\begin{lstlisting}
Αναχώρηση (μορφή ωω:λλ)>19:30
Διάρκεια (μορφή ωω:λλ)>5:40
25:-2 μ.μ.
\end{lstlisting}
Θα πρέπει λοιπόν να φτιάξουμε το άθροισμα της ώρας να μην ξεπερνάει το 24.
\begin{lstlisting}
anax = input('Αναχώρηση (μορφή ωω:λλ)>')
diarkeia = input('Διάρκεια (μορφή ωω:λλ)>')
anaxWra = int(anax.split(':')[0])
anaxLepta = int(anax.split(':')[1])
diarkeiaWra = int(diarkeia.split(':')[0])
diarkeiaLepta = int(diarkeia.split(':')[1])
athroismaLepta = anaxLepta + diarkeiaLepta
telikaLepta = athroismaLepta % 60
telikiWra = (anaxWra + diarkeiaWra + athroismaLepta // 60) % 24
if telikiWra > 12:
    print(str(telikiWra ) + ':' + str(telikaLepta -12)+ ' μ.μ.')
else:
    print(str(telikiWra)+':'+str(telikaLepta) + 'π.μ.')
\end{lstlisting}

Τότε παίρνουμε το σωστό αποτέλεσμα:
\begin{lstlisting}
Αναχώρηση (μορφή ωω:λλ)>19:30
Διάρκεια (μορφή ωω:λλ)>5:40
1:10π.μ.
\end{lstlisting}

β)
Ο δεύτερος τρόπος είναι να χρησιμοποιήσουμε τη βιβλιοθήκη datetime η οποία χρειάζεται κάποιους ειδικούς χειρισμούς.
\begin{lstlisting}
import datetime

anax = input('Αναχώρηση (μορφή ωω:λλ)>')
diarkeia = input('Διάρκεια (μορφή ωω:λλ)>')
anaxWra = int(anax.split(':')[0])
anaxLepta = int(anax.split(':')[1])
diarkeiaWra = int(diarkeia.split(':')[0])
diarkeiaLepta = int(diarkeia.split(':')[1])
t = datetime.time(9,10)
t = datetime.datetime.combine(datetime.date(2020,5,25),t)
d = datetime.timedelta(hours = 4, minutes=57)
print((t+d).strftime('%H:%M'))
\end{lstlisting}

Μπορούμε να μικρύνουμε λίγο ακόμη το πρόγραμμα ως εξής:
\begin{lstlisting}
import datetime

anax = input('Αναχώρηση (μορφή ωω:λλ)>')
diarkeia = input('Διάρκεια (μορφή ωω:λλ)>')
t = datetime.time(int(anax.split(':')[0]),int(anax.split(':')[1]))
t = datetime.datetime.combine(datetime.date(2020,5,25),t)
d = datetime.timedelta(hours = int(diarkeia.split(':')[0]), 
    minutes=int(diarkeia.split(':')[1]))
print((t+d).strftime('%H:%M'))
\end{lstlisting}

Το αποτέλεσμα του προγράμματος με τα δεδομένα του προβλήματος είναι:
\begin{lstlisting}
Αναχώρηση (μορφή ωω:λλ)>9:10
Διάρκεια (μορφή ωω:λλ)>4:57
14:07
\end{lstlisting}

Αν δώσουμε διαφορετικά δεδομένα παίρνουμε σωστές απαντήσεις:
\begin{lstlisting}
Αναχώρηση (μορφή ωω:λλ)>14:10
Διάρκεια (μορφή ωω:λλ)>5:30
19:40
\end{lstlisting}

και για τις ειδικές περιπτώσεις:
\begin{lstlisting}
Αναχώρηση (μορφή ωω:λλ)>19:30
Διάρκεια (μορφή ωω:λλ)>5:40
01:10
\end{lstlisting}

\begin{exercise}
\sel{67}
Να βρεθεί η περίμετρος του σχήματος: (α) σε μέτρα, (β) σε εκατοστά και
(γ) σε χιλιόμετρα.
\end{exercise}
Λύση
(α) Η περίμετρος σε μέτρα είναι ίση με το άθροισμα
των μηκών των πλευρών του, δηλαδή:
\begin{lstlisting}
>>> 26.6+23.5+22.17+38.53
111.8
\end{lstlisting}
Για να το μετατρέψουμε σε εκατοστά θα πολλαπλασιάσουμε με το 100
\begin{lstlisting}
>>> 111.8*100
11180
\end{lstlisting}
Για να το μετατρέψουμε σε χιλιόμετρα θα διαιρέσουμε με το 1000:
\begin{lstlisting}
>>> 111.8/1000
0,1118
\end{lstlisting}

\begin{exercise}
\sel{67}
Μια δεξαμενή νερού τρύπησε και χύνονται 2 σταγόνες κάθε δευτερόλεπτο. Αν οι 25
σταγόνες έχουν μάζα 1,5 g, να βρεθεί η μάζα του νερού που χάνεται κάθε ώρα,
σε κιλά.
\end{exercise}
Κάθε δευτερόλεπτο χάνονται 2 σταγόνες νερού επομένως κάθε ώρα χάνονται:
\begin{lstlisting}
>>> 2* 60 * 60
7200
\end{lstlisting}
Αυτές τις 7200 τις διαιρούμε με το 25 και τις πολλαπλασιάζουμε με τη μάζα των 25 σταγόνων και έχουμε:
\begin{lstlisting}
>>> 7200/25*1.5
432
\end{lstlisting}
Αυτή η μάζα είναι σε γραμμάρια για να βρούμε σε κιλά διαιρούμε με το 1000.
\begin{lstlisting}
>>> 432/1000
0.432
\end{lstlisting}
Μπορούμε να γράψουμε και ένα πρόγραμμα για να υπολογίζει τη μάζα του νερού που χάνεται σε μια πιο γενική περίπτωση. Ας πούμε ότι τα δεδομένα μας θα είναι πόσες σταγόνες χάνονται το δευτερόλεπτο και η μάζα της σταγόνας. Να γραφεί ένα πρόγραμμα που όταν δίνεται η μάζα μιας σταγόνας και το πλήθος των σταγόνων που χύνεται κάθε δευτερόλεπτο, να υπολογίζει τη μάζα του νερού που χύνεται κάθε ώρα σε κιλά.
Το πρόγραμμα θα είναι το εξής:
\begin{lstlisting}
plithos = int(input('Σταγόνες το δευτερόλεπτο:'))
maza = float(input('Μάζα κάθε σταγόνας:'))
grammaria = plithos*maza*60*60
kila = grammaria / 1000
print('Χάνονται ',kila, ' κιλά.')
\end{lstlisting}
Ένα παράδειγμα εκτέλεσης του παραπάνω προγράμματος είναι:
\begin{lstlisting}
Σταγόνες το δευτερόλεπτο:2
Μάζα κάθε σταγόνας:0.05
Χάνονται  0.36  κιλά.
\end{lstlisting}